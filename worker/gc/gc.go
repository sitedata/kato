// Copyright (C) Gridworkz Co., Ltd.
// KATO, Application Management Platform

// Permission is hereby granted, free of charge, to any person obtaining a copy of this 
// software and associated documentation files (the "Software"), to deal in the Software
// without restriction, including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons 
// to whom the Software is furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all copies or
// substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

package gc

import (
	"context"
	"fmt"
	"os"
	"path"

	eventutil "github.com/gridworkz/kato/eventlog/util"
	"github.com/gridworkz/kato/worker/discover/model"
	"github.com/sirupsen/logrus"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/client-go/kubernetes"
)

// GarbageCollector -
type GarbageCollector struct {
	clientset kubernetes.Interface
}

// NewGarbageCollector -
func NewGarbageCollector(clientset kubernetes.Interface) *GarbageCollector {
	gcr := &GarbageCollector{
		clientset: clientset,
	}
	return gcr
}

// DelLogFile deletes persistent data related to the service based on serviceID.
func (g *GarbageCollector) DelLogFile(serviceGCReq model.ServiceGCTaskBody) {
	logrus.Infof("service id: %s; delete log file.", serviceGCReq.ServiceID)
	// log generated during service running
	logPath := "/grdata/logs"
	dockerLogPath := eventutil.DockerLogFilePath(logPath, serviceGCReq.ServiceID)
	if err := os.RemoveAll(dockerLogPath); err != nil {
		logrus.Warningf("remove docker log files: %v", err)
	}
	// log generated by the service event
	eventLogPath := eventutil.EventLogFilePath(logPath)
	for _, eventID := range serviceGCReq.EventIDs {
		eventLogFileName := eventutil.EventLogFileName(eventLogPath, eventID)
		logrus.Debugf("remove event log file: %s", eventLogFileName)
		if err := os.RemoveAll(eventLogFileName); err != nil {
			logrus.Warningf("file: %s; remove event log file: %v", eventLogFileName, err)
		}
	}
}

// DelVolumeData -
func (g *GarbageCollector) DelVolumeData(serviceGCReq model.ServiceGCTaskBody) {
	f := func(prefix string) {
		dir := path.Join(prefix, fmt.Sprintf("tenant/%s/service/%s", serviceGCReq.TenantID, serviceGCReq.ServiceID))
		logrus.Infof("volume data. delete %s", dir)
		if err := os.RemoveAll(dir); err != nil {
			logrus.Warningf("dir: %s; remove volume data: %v", dir, err)
		}
	}
	f("/grdata")
}

// DelPvPvcByServiceID -
func (g *GarbageCollector) DelPvPvcByServiceID(serviceGCReq model.ServiceGCTaskBody) {
	logrus.Infof("service_id: %s", serviceGCReq.ServiceID)
	deleteOpts := metav1.DeleteOptions{}
	listOpts := g.listOptionsServiceID(serviceGCReq.ServiceID)
	if err := g.clientset.CoreV1().PersistentVolumes().DeleteCollection(context.Background(), deleteOpts, listOpts); err != nil {
		logrus.Warningf("service id: %s; delete a collection fo PV: %v", serviceGCReq.ServiceID, err)
	}

	if err := g.clientset.CoreV1().PersistentVolumeClaims(serviceGCReq.TenantID).DeleteCollection(context.Background(), deleteOpts, listOpts); err != nil {
		logrus.Warningf("service id: %s; delete a collection fo PVC: %v", serviceGCReq.ServiceID, err)
	}
}

// DelKubernetesObjects deletes all kubernetes objects.
func (g *GarbageCollector) DelKubernetesObjects(serviceGCReq model.ServiceGCTaskBody) {
	deleteOpts := metav1.DeleteOptions{}
	listOpts := g.listOptionsServiceID(serviceGCReq.ServiceID)
	if err := g.clientset.AppsV1().Deployments(serviceGCReq.TenantID).DeleteCollection(context.Background(), deleteOpts, listOpts); err != nil {
		logrus.Warningf("[DelKubernetesObjects] delete deployments(%s): %v", serviceGCReq.ServiceID, err)
	}
	if err := g.clientset.AppsV1().StatefulSets(serviceGCReq.TenantID).DeleteCollection(context.Background(), deleteOpts, listOpts); err != nil {
		logrus.Warningf("[DelKubernetesObjects] delete statefulsets(%s): %v", serviceGCReq.ServiceID, err)
	}
	if err := g.clientset.ExtensionsV1beta1().Ingresses(serviceGCReq.TenantID).DeleteCollection(context.Background(), deleteOpts, listOpts); err != nil {
		logrus.Warningf("[DelKubernetesObjects] delete ingresses(%s): %v", serviceGCReq.ServiceID, err)
	}
	if err := g.clientset.CoreV1().Secrets(serviceGCReq.TenantID).DeleteCollection(context.Background(), deleteOpts, listOpts); err != nil {
		logrus.Warningf("[DelKubernetesObjects] delete secrets(%s): %v", serviceGCReq.ServiceID, err)
	}
	if err := g.clientset.CoreV1().ConfigMaps(serviceGCReq.TenantID).DeleteCollection(context.Background(), deleteOpts, listOpts); err != nil {
		logrus.Warningf("[DelKubernetesObjects] delete configmaps(%s): %v", serviceGCReq.ServiceID, err)
	}
	if err := g.clientset.AutoscalingV2beta2().HorizontalPodAutoscalers(serviceGCReq.TenantID).DeleteCollection(context.Background(), deleteOpts, listOpts); err != nil {
		logrus.Warningf("[DelKubernetesObjects] delete hpas(%s): %v", serviceGCReq.ServiceID, err)
	}
	// kubernetes does not support api for deleting collection of service
	// read: https://github.com/kubernetes/kubernetes/issues/68468#issuecomment-419981870
	serviceList, err := g.clientset.CoreV1().Services(serviceGCReq.TenantID).List(context.Background(), listOpts)
	if err != nil {
		logrus.Warningf("[DelKubernetesObjects] list services(%s): %v", serviceGCReq.ServiceID, err)
	} else {
		for _, svc := range serviceList.Items {
			if err := g.clientset.CoreV1().Services(serviceGCReq.TenantID).Delete(context.Background(), svc.Name, deleteOpts); err != nil {
				logrus.Warningf("[DelKubernetesObjects] delete service(%s): %v", svc.GetName(), err)
			}
		}
	}
	// delete endpoints after deleting services
	if err := g.clientset.CoreV1().Endpoints(serviceGCReq.TenantID).DeleteCollection(context.Background(), deleteOpts, listOpts); err != nil {
		logrus.Warningf("[DelKubernetesObjects] delete endpoints(%s): %v", serviceGCReq.ServiceID, err)
	}
}

func (g *GarbageCollector) listOptionsServiceID(serviceID string) metav1.ListOptions {
	labelSelector := metav1.LabelSelector{MatchLabels: map[string]string{
		"creator":    "Kato",
		"service_id": serviceID,
	}}
	return metav1.ListOptions{
		LabelSelector: labels.Set(labelSelector.MatchLabels).String(),
	}
}
